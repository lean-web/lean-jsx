"use strict";(self.webpackChunklean_jsx_docs=self.webpackChunklean_jsx_docs||[]).push([[9886],{876:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(2784);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},f=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(n),f=r,m=d["".concat(l,".").concat(f)]||d[f]||u[f]||o;return n?a.createElement(m,i(i({ref:t},p),{},{components:n})):a.createElement(m,i({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=f;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}f.displayName="MDXCreateElement"},8343:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var a=n(7896),r=(n(2784),n(876));const o={sidebar_position:6},i="Use cases and limitations",s={unversionedId:"architecture/use-cases",id:"architecture/use-cases",title:"Use cases and limitations",description:"LeanJSX's approach to handling both static and dynamic content sets some hard constraints on how developers build their applications, and defines the type of web applications for which LeanJSX is a good tool.",source:"@site/docs/architecture/use-cases.md",sourceDirName:"architecture",slug:"/architecture/use-cases",permalink:"/docs/architecture/use-cases",draft:!1,tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"Event handlers, state, and context management",permalink:"/docs/architecture/state-and-context"},next:{title:"Getting started",permalink:"/docs/category/getting-started"}},l={},c=[{value:"Limitations and alternatives",id:"limitations-and-alternatives",level:2},{value:"Fully dynamic web apps",id:"fully-dynamic-web-apps",level:3},{value:"Fully static web apps",id:"fully-static-web-apps",level:2}],p={toc:c},d="wrapper";function u(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"use-cases-and-limitations"},"Use cases and limitations"),(0,r.kt)("p",null,"LeanJSX's approach to handling ",(0,r.kt)("a",{parentName:"p",href:"/docs/architecture/static-vs-dynamic"},"both static and dynamic content")," sets some hard constraints on how developers build their applications, and defines the type of web applications for which LeanJSX is a good tool."),(0,r.kt)("p",null,"The main use case for LeanJSX is building ",(0,r.kt)("strong",{parentName:"p"},"semi-dynamic web applications"),": Applications where most of the conten is static, and only one or two components are dynamic can avoid the overhead of full JavaScript frameworks, while still keeping the benefits of component-based UI development and asynchronous rendering."),(0,r.kt)("p",null,"Other use cases are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Server-driven, performance-critical web applications"),". LeanJSX focuses providing fast content responses with low overhead from JavaScript bundles. Applications that favor performance over dynamic behavior can greatly benefit from LeanJSX."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Web applications for low-end mobile devices and slow-networks"),". Web applications that rely on server-rendered content, but are targeted to users with low-end mobile devices, or users who live in geographic areas with poor network coverage and speeds. PWAs (",(0,r.kt)("a",{parentName:"li",href:"https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps"},"Progressive Web Applications"),") can easily be build on top of LeanJSX.")),(0,r.kt)("h2",{id:"limitations-and-alternatives"},"Limitations and alternatives"),(0,r.kt)("h3",{id:"fully-dynamic-web-apps"},"Fully dynamic web apps"),(0,r.kt)("p",null,"The support for fully-dynamic applications is very limited in LeanJSX. This is intentional."),(0,r.kt)("p",null,"By opting out of supporting component state tracking and diffing in the browser, LeanJSX loses a lot of the features needed for fully-dynamic behavior, but it wins a boost in performance. This is a welcomed trade-off."),(0,r.kt)("p",null,"Another limitation for dynamic behavior is that most content updates in LeanJSX are based on fully replacing large areas of the page with pure HTML. Applications that heavily rely to retain user state on multiple places of the page while also needing to update their contents may find LeanJSX approach too limiting."),(0,r.kt)("p",null,"LeanJSX is not complete replacement for frameworks like React, Angular, Vue, Ember or Svelte. By itself, LeanJSX is not really a framework, but a server-driven templating engine with predefined conventions."),(0,r.kt)("p",null,"For web applications whose most of their contents are fully dynamic in nature, JavaScript frameworks are a better option."),(0,r.kt)("h2",{id:"fully-static-web-apps"},"Fully static web apps"),(0,r.kt)("p",null,"LeanJSX is an excellent tool to build completely static web applications: Applications whose contents are not changed during the lifetime of a single page load: Blogs, news sites, and so on."),(0,r.kt)("p",null,"However, a simpler option for this use cases is to just use static HTML/JS/CSS."),(0,r.kt)("p",null,"A static web application hosted on a CDN has many advantages over any server-rendered web application:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Easier to maintain. No server-side code."),(0,r.kt)("li",{parentName:"ul"},"Lower hosting costs (no need for servers that run NodeJS or similar stacks)."),(0,r.kt)("li",{parentName:"ul"},"Cacheable by default.")),(0,r.kt)("p",null,"Having said that, LeanJSX support of HTTP chunking can offer some additional performance benefits over some CDNs that don't offer this feature out-of-the box."))}u.isMDXComponent=!0}}]);