"use strict";(self.webpackChunklean_jsx_docs=self.webpackChunklean_jsx_docs||[]).push([[1789],{876:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>u});var a=t(2784);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=a.createContext({}),p=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},c=function(e){var n=p(e.components);return a.createElement(l.Provider,{value:n},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},h=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=p(t),h=o,u=d["".concat(l,".").concat(h)]||d[h]||m[h]||i;return t?a.createElement(u,r(r({ref:n},c),{},{components:t})):a.createElement(u,r({ref:n},c))}));function u(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var i=t.length,r=new Array(i);r[0]=h;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[d]="string"==typeof e?e:o,r[1]=s;for(var p=2;p<i;p++)r[p]=t[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}h.displayName="MDXCreateElement"},5442:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var a=t(7896),o=(t(2784),t(876));const i={sidebar_position:2},r="Server-side JSX",s={unversionedId:"architecture/components",id:"architecture/components",title:"Server-side JSX",description:"LeanJSX takes advantage of the collocation of HTML and JavaScript and abstracts away all the setup needed to connect action handlers with elements.",source:"@site/docs/architecture/components.md",sourceDirName:"architecture",slug:"/architecture/components",permalink:"/lean-jsx/docs/architecture/components",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"The engine",permalink:"/lean-jsx/docs/architecture/the-engine"},next:{title:"HTTP streaming",permalink:"/lean-jsx/docs/architecture/streaming"}},l={},p=[{value:"Nested components",id:"nested-components",level:2},{value:"Asynchronous components",id:"asynchronous-components",level:2},{value:"On inlined script tags",id:"on-inlined-script-tags",level:3},{value:"Loading states",id:"loading-states",level:2},{value:"Using the &lt;Lazy/&gt; helper",id:"using-the-lazy-helper",level:3},{value:"Using an async-generator component",id:"using-an-async-generator-component",level:3},{value:"Class-based components",id:"class-based-components",level:2}],c={toc:p},d="wrapper";function m(e){let{components:n,...t}=e;return(0,o.kt)(d,(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"server-side-jsx"},"Server-side JSX"),(0,o.kt)("p",null,"LeanJSX takes advantage of the collocation of HTML and JavaScript and abstracts away all the setup needed to connect action handlers with elements."),(0,o.kt)("p",null,"LeanJSX relies on TypeScript to provide an implementation for JSX that doesn't rely on React for rendering."),(0,o.kt)("p",null,"Given JSX code like the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"function Home() {\n    return <main>\n            <h1>Title</h1>\n            <p>Some text here</p>\n        </main>\n}\n")),(0,o.kt)("p",null,"We can write HTTP server handlers like the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},'// using Express:\napp.use("/", async (req, res) => {\n    // retrieve query parameters from the request\n    const globalContext = parseQueryParams(req);\n\n    // stream HTML into the response,\n    // passing the data from query params\n    await LeanEngine.renderWithTemplate(\n        res,\n        <Home />,\n        globalContext,\n        {\n            // use a template for the\n            // HTML page skeleton\n            templateName: "index"\n        }\n    );\n});\n')),(0,o.kt)("p",null,"In this example, we're using a base template ",(0,o.kt)("inlineCode",{parentName:"p"},"index.html")," with a placeholder where the contents of the response will be rendered:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-html"},'<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <link rel="icon" type="image/svg+xml" href="/icon.svg" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <meta name="description" content="A sample web app to test the capabilities of lean.jsx">\n    <title>lean.jsx: Sample app</title>\n    <link rel="stylesheet" href="./web/app.css">\n    <script type="module" src="./web/app.js"><\/script>\n    \n  </head>\n  <body>\n    \x3c!--EAGER_CONTENT--\x3e\n  </body>\n</html>\n')),(0,o.kt)("p",null,"In this example, ",(0,o.kt)("inlineCode",{parentName:"p"},"\x3c!--EAGER_CONTENT--\x3e")," will be replaced with the HTML generated from ",(0,o.kt)("inlineCode",{parentName:"p"},"<Home/>"),"."),(0,o.kt)("p",null,"LeanJSX-generated projects use ",(0,o.kt)("a",{parentName:"p",href:"https://vitejs.dev/"},"Vite")," to pre-process and bundle client-side static resources like CSS and JavaScript, but ",(0,o.kt)("inlineCode",{parentName:"p"},"./web/app.js")," itself has only logic needed for your application:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"// Add client-code here:\n")),(0,o.kt)("p",null,"The actual response looks like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-html"},'<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <link rel="icon" type="image/svg+xml" href="/icon.svg" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <meta name="description" content="A sample web app to test the capabilities of lean.jsx">\n    <title>lean.jsx: Sample app</title>\n    <script type="module" crossorigin src="/assets/index-d796da6d.js"><\/script>\n    <link rel="stylesheet" href="/assets/index-e50b81c3.css">\n    <script src="/assets/injected_lean-jsx.js"><\/script>\n  </head>\n  <body>\n    <main><h1>Title</h1><p>Some text here</p></main>\n  </body>\n</html>\n')),(0,o.kt)("p",null,"The benefit of this approach is that, for static content no JavaScript is needed to render the JSX-defined contents, which considerably reduces ",(0,o.kt)("strong",{parentName:"p"},"Time to First Byte (TTFB)")," performance metrics."),(0,o.kt)("p",null,"Notice that the page includes a ",(0,o.kt)("inlineCode",{parentName:"p"},"/assets/injected_lean-jsx.js")," script which isn't defined in the original template. This script is injected during the bundle process and includes a minimal set of JavaScript code which LeanJSX uses for ",(0,o.kt)("strong",{parentName:"p"},"asynchronous components"),"."),(0,o.kt)("h2",{id:"nested-components"},"Nested components"),(0,o.kt)("p",null,"LeanJSX components can pass props and children elements as in regular React components:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"interface MyProps extends SXL.Props {\n    title:string;\n}\n\nexport function Layout({ title, children }: MyProps) {\n   return <>\n        <h1>{title}<h1/>\n        <div>{children}</div>\n   </>\n}\n\n// usage:\n<Layout title={'Page1'}>\n    <p>Page contents</p>\n</Layout>\n")),(0,o.kt)("p",null,"When using TypeScript, the global namespace ",(0,o.kt)("inlineCode",{parentName:"p"},"SXL")," is a more specific implementation of the ",(0,o.kt)("inlineCode",{parentName:"p"},"JSX")," global namespace, and ",(0,o.kt)("inlineCode",{parentName:"p"},"SXL.Props")," is the default type for all LeanJSX-based components."),(0,o.kt)("h2",{id:"asynchronous-components"},"Asynchronous components"),(0,o.kt)("p",null,"Server-defined components have the advantage of being close to data resources like databases and internal services. A JSX component can fetch data without relying on browsers making additional network requests."),(0,o.kt)("p",null,"LeanJSX components can be ",(0,o.kt)("strong",{parentName:"p"},"asynchronous"),", returning a Promise with a JSX element:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"async function Home() {\n    const data = await fetchData();\n    return <main>\n            <h1>Title</h1>\n            <p>{data.fetchedData}</p>\n        </main>\n}\n")),(0,o.kt)("p",null,"We could just ",(0,o.kt)("em",{parentName:"p"},"await")," for the component to fetch its data, but that would block any content that will render after it. If the first element in the page takes too long to load data, users may just stare at a blank page."),(0,o.kt)("p",null,"Instead, LeanJSX ",(0,o.kt)("strong",{parentName:"p"},"defers")," all async components by default: When the component is first evaluated, a ",(0,o.kt)("strong",{parentName:"p"},"placeholder")," will be immediately emitted, which unblocks the rendering of subsequent components. Once the async response finishes loading, its contents are emitted to the client, and LeanJSX replaces the original placeholder with the updated contents using JavaScript:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-html"},'<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <link rel="icon" type="image/svg+xml" href="/icon.svg" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <meta name="description" content="A sample web app to test the capabilities of lean.jsx">\n    <title>lean.jsx: Sample app</title>\n    \n    <script type="module" crossorigin src="/assets/index-d796da6d.js"><\/script>\n    <link rel="stylesheet" href="/assets/index-e50b81c3.css">\n    <script src="/assets/injected_lean-jsx.js"><\/script>\n  </head>\n  <body>\n    <div data-placeholder="element-0"></div>\n    \x3c!-- Elements after the async component will not be blocked --\x3e\n    <template id="element-0">\n        <main>\n            <h1>Title</h1>\n            <p>This is async fetched data</p>\n        </main>\n    </template>\n    <script>\n        sxl.fillPlaceHolder("element-0");  \n    <\/script>\n  </body>\n</html>\n')),(0,o.kt)("p",null,"Let's review what happens here:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"When the server evaluates ",(0,o.kt)("inlineCode",{parentName:"li"},"<Home/>"),", it detects that the component is async."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},'<div data-placeholder="element-0"></div>')," is immediately sent to the response."),(0,o.kt)("li",{parentName:"ul"},"While the async content is pending, rendering of other components continue."),(0,o.kt)("li",{parentName:"ul"},"Once the async content completes, ",(0,o.kt)("inlineCode",{parentName:"li"},'<template id="element-0">...</template>')," is sent to the client, along a small inline ",(0,o.kt)("inlineCode",{parentName:"li"},"<script>")," which calls a single function: ",(0,o.kt)("inlineCode",{parentName:"li"},'sxl.fillPlaceHolder("element-0")'),".",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"If the component defined any event handlers (like ",(0,o.kt)("inlineCode",{parentName:"li"},"onclick"),"), the handler code will also be emitted in this inline script tag, which allows the rendered component to be immediately ",(0,o.kt)("strong",{parentName:"li"},"interactive"),", even before the page finishes loading."))),(0,o.kt)("li",{parentName:"ul"},"As soon as the inline script tag is rendered in the browser, the placeholder is replaced with the contents of ",(0,o.kt)("inlineCode",{parentName:"li"},"<template>"),".")),(0,o.kt)("h3",{id:"on-inlined-script-tags"},"On inlined script tags"),(0,o.kt)("p",null,"The idea of rendering inline JavaScript may sound like a bad practice, but it one huge benefit: Asynchronous components and any event handlers they define will be defined as soon as the component is rendered, without waiting for external scripts to load."),(0,o.kt)("p",null,"If instead of relying on inlined ",(0,o.kt)("inlineCode",{parentName:"p"},"<script>")," elements we were to rely on independently loaded JavaScript bundles, asynchronous components and event handlers would only be available ",(0,o.kt)("em",{parentName:"p"},"after the whole page finishes loading"),": ",(0,o.kt)("inlineCode",{parentName:"p"},'<script src="..."/>')," elements are defered to avoid blocking rendering. Inline tags allows us to considerably improve ",(0,o.kt)("a",{parentName:"p",href:"https://developer.chrome.com/en/docs/lighthouse/performance/interactive/"},"Time to interactive")," performance metrics."),(0,o.kt)("h2",{id:"loading-states"},"Loading states"),(0,o.kt)("p",null,"Async components as we defined in the previous example will emit an empty placeholder. This may not provide the best user experience, as it could lead to visible ",(0,o.kt)("a",{parentName:"p",href:"https://developers.google.com/speed/docs/insights/browser-reflow"},"reflow"),"."),(0,o.kt)("p",null,'A better experience would be to provide intermediate or "loading" content while the actual content is being calculated. This can be achieved in multiple ways in LeanJSX:'),(0,o.kt)("h3",{id:"using-the-lazy-helper"},"Using the ","<","Lazy/",">"," helper"),(0,o.kt)("p",null,"LeanJSX provides a ",(0,o.kt)("inlineCode",{parentName:"p"},"Lazy")," component out-of-the box that allows developers to configure a loading state:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"<Lazy loading={<>Loading...</>}>\n    <Home/>\n</Lazy>\n")),(0,o.kt)("p",null,"This is similar to how ",(0,o.kt)("a",{parentName:"p",href:"https://react.dev/reference/react/Suspense"},"React Suspense")," deals with loading states for components that need to await for asynchronous data to load."),(0,o.kt)("p",null,"In LeanJSX, ",(0,o.kt)("inlineCode",{parentName:"p"},"<Lazy/>")," just adds content to the placeholder element:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-html"},'<div data-placeholder="element-0">Loading...</div>\n\x3c!-- Elements after the async component will not be blocked --\x3e\n<template id="element-0">\n    <main>\n        <h1>Title</h1>\n        <p>This is async fetched data</p>\n    </main>\n</template>\n')),(0,o.kt)("h3",{id:"using-an-async-generator-component"},"Using an async-generator component"),(0,o.kt)("p",null,"For developers who need to control the loading state from within the same component that renders the final content, LeanJSX supports ",(0,o.kt)("a",{parentName:"p",href:"https://javascript.info/async-iterators-generators"},"async-generator-based")," components:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"async function* MyComponent() {\n    yield (<>Loading</>);\n    const data = await fetchData();\n    return <main>\n            <h1>Title</h1>\n            <p>{data.fetchedData}</p>\n        </main>\n}\n")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Note: Currently, async-gen components only supporting one single ",(0,o.kt)("inlineCode",{parentName:"p"},"yield")," statement for returning loading states and one ",(0,o.kt)("inlineCode",{parentName:"p"},"return")," statement to return the final content. This may change in the future, if users report the need for more intermediate states.")),(0,o.kt)("h2",{id:"class-based-components"},"Class-based components"),(0,o.kt)("p",null,"Finally, another approach to provide loading content is to create component-based components:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"class MyComponent {\n    props: SXL.Props;\n\n    constructor(props: SXL.Props) {\n        this.props = props;\n    }\n\n    onLoading() {\n        return <div>Loading...</div>;\n    }\n\n    async render() {\n        const data = await fetchData()\n        return <div>{data}</div>;\n    }\n}\n")),(0,o.kt)("p",null,"By implementing the optional, non-asynchronous method ",(0,o.kt)("inlineCode",{parentName:"p"},"onLoading"),", developers can indicate to LeanJSX to use this content as the placeholder for the asynchronous content."))}m.isMDXComponent=!0}}]);